# -*- coding: utf-8 -*-
"""FashionMNISTfaile_b.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1kgc0JdXW4QRgQG2Gs6oy7e5YQ01IPKFE
"""

#from google.colab import drive
#drive.mount('/content/drive')

"""# Importing Libraries"""

import multiprocessing as mp
import pandas as pd
import numpy as np
import math
import time
from cvxopt import matrix
from cvxopt import solvers
from sklearn.svm import LinearSVC
from sklearn.svm import SVC
from scipy.spatial import distance
from multiprocessing import Process
from multiprocessing import Pool
from itertools import combinations

"""# Data"""

trainingData = pd.read_csv("drive/My Drive/ML/fashion_mnist/train.csv",
header = None)

testingData = pd.read_csv("drive/My Drive/ML/fashion_mnist/test.csv",
header = None)

valData = pd.read_csv("drive/My Drive/ML/fashion_mnist/val.csv",
header = None)

xvalidation = np.array(valData.iloc[:,:-1]/255)
yvalidationClass = np.array(valData.iloc[:,-1])

xtesting = np.array(testingData.iloc[:,:-1]/255)
ytestingClass = np.array(testingData.iloc[:,-1])

xtraining = np.array(trainingData.iloc[:,:-1]/255)
ytrainingClass = np.array(trainingData.iloc[:,-1])

size = np.unique(ytrainingClass).size
trainingDataSize = xtraining.shape[0]
testDataSize = xtesting.shape[0]
validateDataSize = xvalidation.shape[0]
getTestClass = np.zeros((size, testDataSize))
getValidateClass = np.zeros((size, validateDataSize))
getTestScore = np.zeros((size, testDataSize))
getValidateScore = np.zeros((size, validateDataSize))

"""# Defining Functions

filter out the two classes n and m
<br>
It gives -1 label to n and 1 label to m
"""

def xy(x, y_class, n, m):
  true = True
  try:
    true = (y_class.shape[1] == 1)
  except IndexError:
    true = True
  finally:
    if true:
      X = np.array([(x[i][:]) for i in range(y_class.shape[0]) if y_class[i] in [n, m]])
      Y = np.array([i for i in y_class if i in [n, m]]).reshape(-1,1)
      Y[Y==m] = -1
      Y[Y==n] =  1
      return X, Y
    else:
      raise Exception("Y not a column matrix")

"""y<sub>m x 1</sub> <br>
(w<sup>T</sup>x)<sub>m x 1</sub> <br>
b is a scaler value
"""

def accuracy(y, wTx, b, n, m, which):
  correct = 0
  incorrect = 0
  for i in range(y.shape[0]):
    final = wTx[i] + b
    if final >= 0:
      if which == 'testing':
        getTestClass[n][i] += 1
        getTestScore[n][i] += np.absolute(final)
      else:
        getValidateClass[n][i] += 1
        getValidateScore[n][i] += np.absolute(final)
      # if(1 * y[i]) > 0:
      #   correct += 1
      # else:
      #   incorrect += 1
    elif final < 0:
      if which == 'testing':
        getTestClass[m][i] += 1
        getTestScore[m][i] += np.absolute(final)
      else:
        getValidateClass[m][i] += 1
        getValidateScore[m][i] += np.absolute(final)
      # if(-1 * y[i]) > 0:
      #   correct += 1
      # else:
      #   incorrect += 1
  # return (correct)/(correct+incorrect)

def QP(ytrainnewclass, xtrainnew, question):
  m = ytrainnewclass.size
  G = matrix(np.concatenate((-np.identity(m), np.identity(m)), axis = 0), tc = 'd')
  h = matrix(np.concatenate((np.zeros((m, 1)), np.ones((m, 1))), axis = 0), tc = 'd')
  A = matrix(ytrainnewclass.T, tc = 'd')
  b = matrix(np.array([0]).reshape((1,1)), tc = 'd')
  q = matrix(-np.ones((m, 1)), tc = 'd')
  if question == 'a':
    P = matrix(np.dot(ytrainnewclass, ytrainnewclass.T) * np.dot(xtrainnew, xtrainnew.T), tc = 'd')
  else:
    gamma = 0.05
    P = matrix(np.dot(ytrainnewclass, ytrainnewclass.T) * K(xtrainnew, xtrainnew, gamma), tc = 'd')
  solvers.options['show_progress'] = False
  sol = solvers.qp(P,q,G,h,A,b)
  alpha = sol['x']
  return alpha

def K(x, z, gamma):
  if gamma == 'a':
    return np.dot(x, z.T)
  else:
    t = distance.cdist(x, z, 'euclidean')
    k = np.exp(-gamma * np.square(t))
    return k

def coef(alpha, y, x, question):
  t = np.dot((alpha * y).T, K(x, x, question)).T
  bmax, bmin = [], []
  for i in range(y.shape[0]):
    if y[i] == -1:
      bmax.append(t[i])
    elif y[i] == 1:
      bmin.append(t[i])
  bmax, bmin = np.array(bmax).max(), np.array(bmin).min()
  return -(1/2) * (bmax + bmin)

"""alpha = (4500, 1)

# Part 1 a
"""

def part1abc(xvalnew, yvalnewclass, xtestnew, ytestnewclass, xtrainnew, ytrainnewclass, question, n, m):
  if question in ['a', 0.05]:
    print("---- Training Start ----")
    start = time.time()
    alpha = QP(ytrainnewclass, xtrainnew, question)
    alpha = np.array(alpha)
    print("alpha is: ", alpha)

    alpha[np.absolute(alpha) <= 1e-5] = 0
    ynew, xnew = map(np.array, list(zip(*[(ytrainnewclass[i], xtrainnew[i]) for i in range(alpha.size) if alpha[i] != 0])))
    alpha = alpha[alpha!=0].reshape(-1, 1)
    print("---- Training Time: ", time.time() - start)

    b = coef(alpha, np.array(ynew), np.array(xnew), question)

    wTx = np.dot((alpha * ynew).T, K(xnew, xtestnew, question)).T
    accuracy(ytestnewclass, wTx, b, n, m, 'testing')

    wTx = np.dot((alpha * ynew).T, K(xnew, xvalnew, question)).T
    accuracy(yvalnewclass, wTx, b, n, m, 'validation')
  elif question in ['clinear', 'cgaussian']:
    start = time.time()
    X, y = (xtrainnew, ytrainnewclass)
    y[y == 1] = n
    y[y == -1] = m
    clf = LinearSVC(random_state=0, tol=1e-5) if question == 'clinear' else SVC(gamma=0.05)
    clf.fit(X, y)
    print("Training Time: ", time.time() - start)
    wTx_b_test = np.absolute(clf.decision_function(xtestnew))
    wTx_b_val = np.absolute(clf.decision_function(xvalnew))
    p_test = clf.predict(xtestnew)
    p_val = clf.predict(xvalnew)
    for i, j in list(enumerate(p_test)):
      getTestClass[int(j)][i] += 1
      getTestScore[int(j)][i] += wTx_b_test[i]
    for i, j in list(enumerate(p_val)):
      getValidateClass[int(j)][i] += 1
      getValidateScore[int(j)][i] += wTx_b_val[i]

def part1(n, m, question):
  print("----", n, m, "----")
  (xtrainnew, ytrainnewclass) = xy(xtraining, ytrainingClass, n, m)
  (xtestnew, ytestnewclass) = (xtesting, ytestingClass)
  (xvalnew, yvalnewclass) = (xvalidation, yvalidationClass)
  return part1abc(xvalnew, yvalnewclass, xtestnew, ytestnewclass, xtrainnew, ytrainnewclass, question, n, m)

LABELS = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
combo = combinations(LABELS, 2)

"""Training time for gaussian in class 6 vs 7 made by self: 
39.255675077438354
"""

def partb():
  def prediction(c, s):
    ret = []
    for i in range(c.T.shape[0]):
      maxClass = c.T[i].max()
      count = []
      l = list()
      for j in range(c.T[i].size):
        if maxClass == c.T[i][j]:
          l.append(j)
      if len(l) > 1:
        maxScore = s.T[i].max()
        sl = []
        for j in range(s.T[i].size):
          if maxScore == s.T[i][j]:
            sl.append(j)
        if len(sl) > 1:
          raise Exception("ties in the test data during classification")
        ret.append((sl[0], i))
      else:
        ret.append((l[0], i))
    return ret
  validatePrediction = prediction(getValidateClass, getValidateScore)
  testPrediction = prediction(getTestClass, getTestScore)
  def accur(yc, tp):
    correct = 0
    incorrect = 0
    for i in range(yc.size):
      if yc[i] == tp[i][0]:
        correct += 1
      else:
        incorrect += 1
    accuracy = correct / (correct + incorrect)
    print(accuracy)
  accuracy = accur(ytestingClass, testPrediction)
  accuracy = accur(yvalidationClass, validatePrediction)
  confidenceMatrix = np.zeros((size, size))
  for i in range(ytestingClass.shape[0]):
    confidenceMatrix[int(ytestingClass[i])][int(testPrediction[i][0])] += 1
  print(confidenceMatrix.T)
  confidenceMatrix = np.zeros((size, size))
  for i in range(yvalidationClass.shape[0]):
    confidenceMatrix[int(yvalidationClass[i])][int(validatePrediction[i][0])] += 1
  print(confidenceMatrix.T)

# wTx_b_test, wTx_b_val, p_test, p_val = part1(0, 1, 'cgaussian')
def main():
  if input("enter 0.05 or cgaussian: ") == "0.05":
    for (n,m) in combo:
      part1(n, m, 0.05)
    partb()
  else:
    for (n,m) in combo:
      part1(n, m, 'cgaussian')
    partb()
main()

"""```
for self gaussian svm

accuracy:
0.8492   test
0.8472   val

confidence matrix  in test
array([[414.,   1.,   2.,  30.,   9.,   6.,  69.,   4.,   2.,   1.],
       [  0., 484.,   0.,   9.,   1.,   0.,   1.,   0.,   0.,   0.],
       [  7.,   6., 414.,   2.,  52.,   0.,  52.,   0.,   1.,   0.],
       [  7.,   2.,   3., 407.,  11.,   0.,   4.,   0.,   0.,   0.],
       [  0.,   0.,  26.,   6., 365.,   0.,  19.,   0.,   0.,   0.],
       [  0.,   0.,   0.,   0.,   0., 432.,   0.,  48.,   0.,   5.],
       [ 62.,   6.,  42.,  36.,  50.,   0., 340.,   0.,   3.,   0.],
       [  0.,   0.,   0.,   0.,   0.,   7.,   0., 410.,   0.,   6.],
       [ 10.,   1.,  13.,  10.,  12.,  43.,  15.,   4., 494.,   2.],
       [  0.,   0.,   0.,   0.,   0.,  12.,   0.,  34.,   0., 486.]])

confidence matrix in validation
array([[203.,   0.,   3.,  21.,   5.,   3.,  25.,   4.,   1.,   0.],
       [  2., 240.,   0.,   7.,   2.,   0.,   0.,   0.,   0.,   0.],
       [  1.,   2., 207.,   0.,  29.,   0.,  27.,   0.,   1.,   0.],
       [  4.,   2.,   1., 193.,   4.,   1.,   1.,   0.,   0.,   0.],
       [  0.,   0.,  13.,   6., 185.,   0.,  11.,   0.,   0.,   0.],
       [  0.,   0.,   0.,   0.,   0., 226.,   0.,  24.,   0.,   2.],
       [ 36.,   3.,  14.,  19.,  19.,   0., 182.,   0.,   1.,   0.],
       [  0.,   0.,   0.,   0.,   0.,   1.,   0., 198.,   2.,   4.],
       [  4.,   3.,  12.,   4.,   6.,  13.,   4.,   3., 245.,   5.],
       [  0.,   0.,   0.,   0.,   0.,   6.,   0.,  21.,   0., 239.]])


for sklearn gaussian
accuracy:
0.8806
0.8788

over test
array([[432.,   1.,   5.,  12.,   2.,   0.,  80.,   0.,   1.,   0.],
       [  0., 482.,   0.,   0.,   1.,   0.,   0.,   0.,   0.,   0.],
       [  5.,   4., 410.,   3.,  39.,   0.,  53.,   0.,   1.,   0.],
       [ 12.,   9.,   7., 456.,  14.,   0.,   9.,   0.,   1.,   0.],
       [  3.,   0.,  37.,   9., 399.,   0.,  34.,   0.,   2.,   0.],
       [  0.,   0.,   0.,   0.,   0., 473.,   0.,  14.,   2.,  11.],
       [ 38.,   4.,  33.,  15.,  39.,   0., 317.,   0.,   2.,   0.],
       [  0.,   0.,   0.,   0.,   0.,  16.,   0., 471.,   2.,  14.],
       [ 10.,   0.,   8.,   5.,   6.,   5.,   7.,   1., 489.,   1.],
       [  0.,   0.,   0.,   0.,   0.,   6.,   0.,  14.,   0., 474.]])

over validation
array([[212.,   0.,   5.,   6.,   1.,   0.,  33.,   0.,   0.,   0.],
       [  0., 237.,   0.,   0.,   1.,   0.,   0.,   0.,   0.,   0.],
       [  1.,   3., 205.,   0.,  24.,   0.,  28.,   0.,   1.,   0.],
       [  8.,   7.,   3., 228.,   8.,   1.,   4.,   0.,   1.,   0.],
       [  0.,   0.,  19.,   6., 200.,   0.,  19.,   0.,   1.,   0.],
       [  0.,   0.,   0.,   0.,   0., 241.,   0.,   8.,   0.,   5.],
       [ 26.,   2.,  13.,   9.,  15.,   0., 165.,   0.,   1.,   0.],
       [  0.,   0.,   0.,   0.,   0.,   2.,   0., 230.,   2.,   8.],
       [  3.,   1.,   5.,   1.,   1.,   1.,   1.,   1., 244.,   2.],
       [  0.,   0.,   0.,   0.,   0.,   5.,   0.,  11.,   0., 235.]])

```
"""
