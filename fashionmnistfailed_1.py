# -*- coding: utf-8 -*-
"""FashionMNISTfailed.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1iVLARDwZTTecudy9hBmktFv4671ZjvSd
"""

#from google.colab import drive
#drive.mount('/content/drive')

# import numpy as np
# arr = np.ones(10**9, dtype = 'float128')

"""# importing Libraries"""

import multiprocessing as mp
import pandas as pd
import numpy as np
import math
import time
from cvxopt import matrix
from cvxopt import solvers
from sklearn.svm import LinearSVC
from sklearn.svm import SVC
from scipy.spatial import distance
from multiprocessing import Process
from multiprocessing import Pool
from itertools import combinations

"""# Data"""

trainingData = pd.read_csv("drive/My Drive/ML/fashion_mnist/train.csv",
header = None)

testingData = pd.read_csv("drive/My Drive/ML/fashion_mnist/test.csv",
header = None)

valData = pd.read_csv("drive/My Drive/ML/fashion_mnist/val.csv",
header = None)

xvalidation = np.array(valData.iloc[:,:-1]/255)
yvalidationClass = np.array(valData.iloc[:,-1])

xtesting = np.array(testingData.iloc[:,:-1]/255)
ytestingClass = np.array(testingData.iloc[:,-1])

xtraining = np.array(trainingData.iloc[:,:-1]/255)
ytrainingClass = np.array(trainingData.iloc[:,-1])

"""# Defining Functions

filter out the two classes n and m
<br>
It gives -1 label to n and 1 label to m
"""

def xy(x, y_class, n, m):
  true = True
  try:
    true = (y_class.shape[1] == 1)
  except IndexError:
    true = True
  finally:
    if true:
      X = np.array([(x[i][:]) for i in range(y_class.shape[0]) if y_class[i] in [n, m]])
      Y = np.array([i for i in y_class if i in [n, m]]).reshape(-1,1)
      Y[Y==m] = -1
      Y[Y==n] =  1
      return X, Y
    else:
      raise Exception("Y not a column matrix")

"""y<sub>m x 1</sub> <br>
(w<sup>T</sup>x)<sub>m x 1</sub> <br>
b is a scaler value
"""

def accuracy(y, wTx, b):
  correct = 0
  incorrect = 0
  for i in range(y.shape[0]):
    if wTx[i] + b >= 0:
      if(1 * y[i]) > 0:
        correct += 1
      else:
        incorrect += 1
    elif wTx[i] + b < 0:
      if(-1 * y[i]) > 0:
        correct += 1
      else:
        incorrect += 1
  return (correct)/(correct+incorrect)

def QP(ytrainnewclass, xtrainnew, question):
  m = ytrainnewclass.size
  G = matrix(np.concatenate((-np.identity(m), np.identity(m)), axis = 0), tc = 'd')
  h = matrix(np.concatenate((np.zeros((m, 1)), np.ones((m, 1))), axis = 0), tc = 'd')
  A = matrix(ytrainnewclass.T, tc = 'd')
  b = matrix(np.array([0]).reshape((1,1)), tc = 'd')
  q = matrix(-np.ones((m, 1)), tc = 'd')
  if question == 'a':
    P = matrix(np.dot(ytrainnewclass, ytrainnewclass.T) * np.dot(xtrainnew, xtrainnew.T), tc = 'd')
  else:
    gamma = 0.05
    P = matrix(np.dot(ytrainnewclass, ytrainnewclass.T) * K(xtrainnew, xtrainnew, gamma), tc = 'd')
  solvers.options['show_progress'] = False
  sol = solvers.qp(P,q,G,h,A,b)
  alpha = sol['x']
  return alpha

def K(x, z, gamma):
  if gamma == 'a':
    return np.dot(x, z.T)
  else:
    t = distance.cdist(x, z, 'euclidean')
    k = np.exp(-gamma * np.square(t))
    return k

def coef(alpha, y, x, question):
  t = np.dot((alpha * y).T, K(x, x, question)).T
  bmax, bmin = [], []
  for i in range(y.shape[0]):
    if y[i] == -1:
      bmax.append(t[i])
    elif y[i] == 1:
      bmin.append(t[i])
  bmax, bmin = np.array(bmax).max(), np.array(bmin).min()
  return -(1/2) * (bmax + bmin)

"""alpha = (4500, 1)

# Part 1 a
"""

def part1abc(xvalnew, yvalnewclass, xtestnew, ytestnewclass, xtrainnew, ytrainnewclass, question):
  if question in ['a', 0.05]:
    print("-----Training Start--------")
    alpha = QP(ytrainnewclass, xtrainnew, question)
    alpha = np.array(alpha)
    alpha[np.absolute(alpha) <= 1e-5] = 0
    ynew, xnew = map(np.array, list(zip(*[(ytrainnewclass[i], xtrainnew[i]) for i in range(alpha.size) if alpha[i] != 0])))
    alpha = alpha[alpha!=0].reshape(-1, 1)
    print("------Testing Start---------")
    b = coef(alpha, np.array(ynew), np.array(xnew), question)
    w = np.dot((alpha * ynew).T, K(xnew, xtestnew, question)).T
    print(question, "Test Accuracy: ", accuracy(ytestnewclass, w, b))
    w = np.dot((alpha * ynew).T, K(xnew, xvalnew, question)).T
    print(question, "Val Accuracy: ", accuracy(yvalnewclass, w, b))
    w = np.dot((alpha * ynew).T, K(xnew, xtrainnew, question)).T
    print(question, "Train Accuracy: ", accuracy(ytrainnewclass, w, b))
  elif question in ['clinear', 'cgaussian']:
    X, y = (xtrainnew, ytrainnewclass)
    clf = LinearSVC(random_state=0, tol=1e-5) if question == 'clinear' else SVC(gamma=0.05)
    start = time.time()
    clf.fit(X, y)
    print("Training Time: ", time.time() - start)
    # print(clf.coef_)
    # print(clf.intercept_)
    print(question, "Accuracy for test sklearn: ", clf.score(xtestnew, ytestnewclass))
    print(question, "Accuracy for train sklearn: ", clf.score(xtrainnew, ytrainnewclass))
    print(question, "Accuracy for val sklearn: ", clf.score(xvalnew, yvalnewclass))

def part1(n, m):
  (xtrainnew, ytrainnewclass) = xy(xtraining, ytrainingClass, n, m)
  (xtestnew, ytestnewclass) = xy(xtesting, ytestingClass, n, m)
  (xvalnew, yvalnewclass) = xy(xvalidation, yvalidationClass, n, m)
  question = ['a', 0.05, 'clinear', 'cgaussian']
  for q in question:
    part1abc(xvalnew, yvalnewclass, xtestnew, ytestnewclass, xtrainnew, ytrainnewclass, q)
  # Parallel(n_jobs=mp.cpu_count())(delayed(part1abc)(xvalnew, yvalnewclass, xtestnew, ytestnewclass, xtrainnew, ytrainnewclass, q) for q in question)
  # pool = Pool(mp.cpu_count())
  # [pool.apply(part1abc, args=(xvalnew, yvalnewclass, xtestnew, ytestnewclass, xtrainnew, ytrainnewclass, q)) for q in question]
  # pool.close()

ques = [0,1,2,3,4,5,6,7,8,9]
processes = []
for n, m in combinations(ques, 2):
  processes.append(Process(target=part1, args=(n, m,)))
for process in processes:
  process.start()
for process in processes:
  process.join()

"""---



```


-----Training Start--------
------Testing Start---------
a Test Accuracy:  1.0
a Val Accuracy:  1.0
a Train Accuracy:  1.0
-----Training Start--------
------Testing Start---------
0.05 Test Accuracy:  0.999
0.05 Val Accuracy:  0.992
0.05 Train Accuracy:  1.0

/usr/local/lib/python3.6/dist-packages/sklearn/utils/validation.py:760: DataConversionWarning: A column-vector y was passed when a 1d array was expected. Please change the shape of y to (n_samples, ), for example using ravel().
  y = column_or_1d(y, warn=True)

Training Time:  0.07267999649047852
clinear Accuracy for test sklearn:  1.0
clinear Accuracy for train sklearn:  1.0
clinear Accuracy for val sklearn:  1.0

/usr/local/lib/python3.6/dist-packages/sklearn/utils/validation.py:760: DataConversionWarning: A column-vector y was passed when a 1d array was expected. Please change the shape of y to (n_samples, ), for example using ravel().
  y = column_or_1d(y, warn=True)

Training Time:  4.010399341583252
cgaussian Accuracy for test sklearn:  0.999
cgaussian Accuracy for train sklearn:  1.0
cgaussian Accuracy for val sklearn:  0.992


```



---
"""

